= Ahead of Time Optimizations

This chapter covers Spring Data's Ahead of Time (AOT) optimizations that build upon {spring-framework-docs}/core/aot.html[Spring's Ahead of Time Optimizations].

[[aot.bestpractices]]
== Best Practices

=== Annotate your Domain Types

During application startup, Spring scans the classpath for domain classes for early processing of entities.
By annotating your domain types with Spring Data-specific `@Table`, `@Document` or `@Entity` annotations you can aid initial entity scanning and ensure that those types are registered with `ManagedTypes` for Runtime Hints.
Classpath scanning is not possible in native image arrangements and so Spring has to use `ManagedTypes` for the initial entity set.

[[aot.hints]]
== Runtime Hints

Running an application as a native image requires additional information compared to a regular JVM runtime.
Spring Data contributes {spring-framework-docs}/core/aot.html#aot.hints[Runtime Hints] during AOT processing for native image usage.
These are in particular hints for:

* Auditing
* `ManagedTypes` to capture the outcome of class-path scans
* Repositories
** Reflection hints for entities, return types, and Spring Data annotations
** Repository fragments
** Querydsl `Q` classes
** Kotlin Coroutine support
* Web support (Jackson Hints for `PagedModel`)

[[aot.repositories]]
== Ahead of Time Repositories

AOT Repositories are an extension to AOT processing by pre-generating eligible query method implementations.
Query methods are opaque to developers regarding their underlying queries being executed in a query method call.
AOT repositories contribute query method implementations based on derived, annotated, and named queries that are known at build-time.
This optimization moves query method processing from runtime to build-time, which can lead to a significant performance improvement as query methods do not need to be analyzed reflectively upon each application start.

The resulting AOT repository fragment follows the naming scheme of `<Repository FQCN>Impl__Aot` and is placed in the same package as the repository interface.
You can find all queries in their String form for generated repository query methods.

=== Running with AOT Repositories

AOT is a mandatory step to transform a Spring application to a native executable, so it is automatically enabled when running in this mode.
It is also possible to use those optimizations on the JVM by setting the `spring.aot.enabled` and `spring.aot.repositories.enabled` System properties to `true`.

AOT repositories contribute configuration changes to the actual repository bean registration to register the generated repository fragment.

NOTE: When AOT optimizations are included, some decisions that have been taken at build-time are hard-coded in the application setup.
For instance, profiles that have been enabled at build-time are automatically enabled at runtime as well.
Also, the Spring Data module implementing a repository is fixed.
Changing the implementation requires AOT re-processing.

=== Eligible Methods

AOT repositories filter methods that are eligible for AOT processing.
These are typically all query methods that are not backed by an xref:repositories/custom-implementations.adoc[implementation fragment].

**Supported Features**

* Derived query methods, `@Query`/`@NativeQuery` and named query methods
* `@Modifying` methods returning `void` or `int`
* `@QueryHints` support
* Pagination, `Slice`, `Stream`, and `Optional` return types
* Sort query rewriting
* DTO Projections
* Value Expressions (Those require a bit of reflective information.
Mind that using Value Expressions requires expression parsing and contextual information to evaluate the expression)

**Limitations**

* `QueryRewriter` is not supported yet
* Methods accepting `ScrollPosition (e.g. `Keyset` pagination) are not supported yet.
* Stored procedure query methods annotated with `@Procedure` are not supported.
* Dynamic and interface projections are not supported yet.

**Excluded methods**

* `CrudRepository` and other base interface methods
* Querydsl and Query by Example methods
* Methods whose implementation would be overly complex
** Methods accepting `ScrollPosition (e.g. `Keyset` pagination)
** Stored procedure query methods annotated with `@Procedure`
** For now: Dynamic and interface projections
