[[jpa.projections]]
= Projections

:projection-collection: Collection

include::{commons}@data-commons::page$repositories/projections-intro.adoc[]

NOTE: It is important to note that <<projections.dtos,Class-based projections>> with JPQL is limited to *constructor expressions* in your JPQL expression, e.g. `SELECT new com.example.NamesOnly(u.firstname, u.lastname) from User u`.
(Note the usage of a FQDN for the DTO type!) This JPQL expression can be used in `@Query` annotations as well where you define any named queries.
And it's important to point out that class-based projections do not work with native queries AT ALL.
As a workaround you may use named queries with `ResultSetMapping` or the Hibernate-specific javadoc:{hibernatejavadocurl}org.hibernate.query.ResultListTransformer[]

include::{commons}@data-commons::page$repositories/projections-interface.adoc[leveloffset=1]

include::{commons}@data-commons::page$repositories/projections-class.adoc[leveloffset=1]



[NOTE]
====
<<projections.dtos,Class-based projection (DTO projections)>> types must declare a single constructor so that Spring Data can determine its input properties.
If your class defines more than one constructor, then you cannot use the type without further hints for DTO projections.
In such a case annotate the desired constructor with `@PersistenceCreator` as outlined below so that Spring Data can determine which properties to select:

[source,java]
----
public class NamesOnly {

    private final String firstname;
    private final String lastname;

    protected NamesOnly() { }

    @PersistenceCreator
    public NamesOnly(String firstname, String lastname) {
        this.firstname = firstname;
        this.lastname = lastname;
    }

    // ...
}
----
====
